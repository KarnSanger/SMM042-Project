import datetime
import random

import numpy as np
import pandas as pd
import math
import matplotlib.pyplot as plt

class TbaseTable:
    def __init__(self, xlFile):
        temp = pd.read_excel(xlFile).to_numpy()
        self.lxm = np.append(temp[:, 1],[0,0])
        self.lxf = np.append(temp[:, 2], [0,0])
        self.age = temp[:,0]

    def lx(self, x, gender):  #0 - males, 1 - female
        if x >= 101:
            return 0
        if x < 0:
            return 100000
        x1 = int(x)
        x2 = x1 + 1
        if gender == 0:
            l1 = self.lxm[x1]
            l2 = self.lxm[x2]
        elif gender == 1:
            l1 = self.lxf[x1]
            l2 = self.lxf[x2]
        else:
            return None
        frac = x - x1
        lx_value = (1 - frac) * l1 + frac * l2
        return lx_value

    def tpx(self, t, x, gender):
        if x > 101:
            return 0
        return self.lx(x+t, gender)/self.lx(x, gender)

class TlifeTable:
    def __init__(self, baseTable, interest):
        self.interest = interest
        self.baseTable = baseTable
    def lx(self, x, gender):
        return self.baseTable.lx(x, gender)
    def tpx(self, t, x, gender):
        return self.baseTable.tpx(t, x, gender)
    def tqx(self, t, x, gender):
        return 1 - self.tpx(t, x, gender)
    def setup_annuities(self):
        self.anndotm = np.empty([102], dtype=float) #setting up an empty vector with 102 elements
        self.anndotm[101] = 0
        self.anndotf = np.empty([102], dtype=float)
        self.anndotf[101] = 0
        for x in range(100, -1, -1):
            self.anndotm[x] = 1 + self.anndotm[x + 1] * self.tpx(1, x, 0)/(1 + self.interest)
            self.anndotf[x] = 1 + self.anndotf[x + 1] * self.tpx(1, x, 1)/(1 + self.interest)
    def anndot(self, age, gender):
        if age > 101:
            return 1
        iage = int(age)
        fage = age - iage
        if gender == 0:
            ann = self.anndotm[iage] * (1-fage) + self.anndotm[iage+1] * fage
        else:
            ann = self.anndotf[iage] * (1-fage) + self.anndotf[iage+1] * fage
        return  ann

    def setup_assurances(self):
        self.asscapm = np.empty([102],dtype = float)
        self.asscapm[101] = 1/(1 + self.interest)
        self.asscapf = np.empty([102], dtype = float)
        self.asscapf[101] = 1/(1 + self.interest)
        for x in range(100, -1, -1):
            self.asscapm[x] = (self.asscapm[x+1] * self.tpx(1, x, 0)+(self.tqx(1, x, 0)))/(1+self.interest)
            self.asscapf[x] = (self.asscapf[x+1] * self.tpx(1, x, 0)+(self.tqx(1, x, 0)))/(1+self.interest)

    def asscap(self, age, gender):
        iage = int(age)
        if age >= 101:
            return 1   #instant death
        fage = age - iage
        if gender == 0:
            ass = self.asscapm[iage] * (1-fage) + self.asscapm[iage+1] * fage
        else:
            ass = self.asscapf[iage] * (1-fage) + self.asscapf[iage+1] * fage
        return ass

class TsuperTable:
    def __init__(self, name, xlFile, interest1, interest2, interestStep):
        self.name = name
        self.interest1 = interest1
        self.interest2 = interest2
        self.interestStep = interestStep
        self.baseTable = TbaseTable(xlFile)
        self.allTables = []
        print("Setup actuarial tables")
        for i in np.arange(interest1, interest2, interestStep):
            newTable = TlifeTable(self.baseTable, i)
            newTable.setup_annuities()
            newTable.setup_assurances()
            self.allTables.append(newTable)
    def annuity(self, age, gender, startOffset, endOffset, pre_interest, interest, pthly):
        if interest < self.interest1:
            i_index = 0
        elif interest >= self.interest2 - self.interestStep * 2:
            fake_interest = self.interest2 - self.interestStep * 2
            i_index = int((fake_interest - self.interest1) / self.interestStep)
        else:
            i_index = int((interest - self.interest1) / self.interestStep)
        i1 = i_index * self.interestStep + self.interest1
        i2 = i1 + self.interestStep
        ifrac = (interest - i1)/(i2 - i1)
        table1 = self.allTables[i_index]
        table2 = self.allTables[i_index + 1]
        ageStart = age + startOffset
        lifeAnnuity_1 = table1.anndot(ageStart, gender)
        lifeAnnuity_2 = table2.anndot(ageStart, gender)
        n_payments = (endOffset - startOffset) * pthly
        n_payments = math.ceil(n_payments)
        ageEnd = age + startOffset + n_payments/pthly
        new_endOffset = ageEnd - age
        endAnnuity_1 = table1.anndot(ageEnd, gender)
        endAnnuity_2 = table2.anndot(ageEnd, gender)
        pthly_adjust = (pthly - 1)/(2 * pthly)
        lifeAnnuity = lifeAnnuity_1 * (1 - ifrac) + lifeAnnuity_2 * ifrac - pthly_adjust
        endAnnuity = endAnnuity_1 * (1 - ifrac) + endAnnuity_2 * ifrac - pthly_adjust
        startDiscount = table1.tpx(startOffset, age, gender)
        endDiscount = (1 + interest) ** (startOffset - new_endOffset) * table1.tpx(new_endOffset, age, gender)
        total_value = (1 + pre_interest) ** (-startOffset) * (startDiscount * (lifeAnnuity) - endDiscount * (endAnnuity))
        return total_value

    def assurance(self, age, gender, startOffset, endOffset, interest, deferral): #deferral is an average: 0 immediate, 0.5 end of the year. slightly inaccurate for non-integer terms
        if interest < self.interest1:
            i_index = 0
        elif interest >= self.interest2 - self.interestStep * 2:
            fake_interest = self.interest2 - self.interestStep * 2
            i_index = int((fake_interest-self.interest1)/self.interestStep)
        else:
            i_index = int((interest - self.interest1)/self.interestStep)
        i1 = i_index * self.interestStep + self.interest1
        i2 = i1 + self.interestStep
        ifrac = (interest - i1)/(i2 - i1)
        table1 = self.allTables[i_index]
        table2 = self.allTables[i_index + 1]
        ageStart = age + startOffset
        startAssurance_1 = table1.asscap(ageStart, gender)
        startAssurance_2 = table2.asscap(ageStart, gender)
        ageEnd = age + endOffset
        endAssurance_1 = table1.asscap(ageEnd, gender)
        endAssurance_2 = table2.asscap(ageEnd, gender)
        startAssurance = startAssurance_1 * (1- ifrac) + startAssurance_2 * ifrac
        endAssurance = endAssurance_1 * (1- ifrac) + endAssurance_2 * ifrac
        startDiscount = (1 + interest) ** (-startOffset) * table1.tpx(startOffset, age, gender)
        endDiscount = (1 + interest) ** (-endOffset) * table1.tpx(endOffset, age, gender)
        total_value = startDiscount * startAssurance - endDiscount * endAssurance
        total_value = total_value * (1 + interest) ** (0.5 - deferral)
        return total_value
    def lx(self, x, gender):
        return self.baseTable.lx(x, gender)
    def tpx(self, t, x, gender):
        return self.baseTable.tpx(t, x, gender)
    def tqx(self, t, x, gender):
        return 1 - self.baseTable.tpx(t, x, gender)

class Tperson:
    def __init__(self, name, DoB, gender):
        self.name = name
        self.DoB = date_in(DoB)
        self.gender = gender

    def randomDeath(self, lifeTable, basis):
        age = basis.calcDate - self.DoB
        iage = int(age)
        age1 = age
        age2 = iage + 1
        while age1 < basis.projDate - basis.calcDate + age:  #return actual date of death
            q_age = lifeTable.tqx(1, iage, self.gender)
            rnd_death = rnd_exp(q_age)
            if rnd_death < age2 - age1:
                return rnd_death + age1 + self.DoB
            age1 = age2
            age2 = age2 + 1
            iage = int(age1)
        return float("NaN")


class Tpolicyholder(Tperson):
    def __init__(self, name, DoB, gender, DoI, pthly):
        Tperson.__init__(self, name, DoB, gender)
        self.DoI = date_in(DoI)
        self.pthly = pthly  #this refers to the premium for assured lives and payment for annuitants
    def PV(self, economy, superTable, date, DoDeath):
        print("Attempting to calculate PV for abstract class")
        return  0
    def cashflows(self, economy, lifeTable, DoDeath):
        print("Attempting to calculate cashflows for abstract class")
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        return cf

class Tassured(Tpolicyholder):
    def __init__(self,name, DoB, gender, DoI, SA, premium, pthly, term):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.SA = SA
        self.term = term
        self.premium = premium
    def PV_out(self, economy, superTable, date, DoDeath):
        if afterDeath(date, DoDeath):
            return 0
        else:
            age = date - self.DoB
            startOffset = max([0, self.DoI - date])
            if np.isnan(self.term):
                endOffset = 100
            else:
                endOffset = self.DoI - date + self.term
            if endOffset < 0:
                return 0
            interest = economy.interest(date)
            deferral = 0
            x = superTable.assurance(age, self.gender, startOffset, endOffset, interest, deferral)
            x = x * self.SA
            return x
    def PV_in(self, economy, superTable, date, DoDeath):
            if afterDeath(date, DoDeath):
                return 0
            else:
                age = date - self.DoB
                startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
                endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
                if np.isnan(startOffset) or np.isnan(endOffset):
                    return 0
                interest = economy.interest(date)
                x = superTable.annuity(age, self.gender, startOffset, endOffset, interest, interest, self.pthly)
                x = x * self.premium * self.pthly
                return x
    def PV(self, economy, superTable, date, DoDeath):
        return self.PV_in(economy, superTable, date, DoDeath) - self.PV_out(economy, superTable, date, DoDeath)
    def cashflows(self, economy, superTable, DoDeath):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        premDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        endTermDate = endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        lastDate = min([minDeath(endTermDate, DoDeath), economy.basis.projDate])
        if np.isnan(premDate) or np.isnan(lastDate):
            return cf
        if afterDeath( min(endTermDate, economy.basis.projDate), DoDeath):
            cf[economy.basis.getIndex(DoDeath)] = -self.SA
        while premDate < lastDate:
            i = economy.basis.getIndex(premDate)
            cf[i] = cf[i] + self.premium
            premDate = premDate + 1 / self.pthly
        return cf



class Tannuitant(Tpolicyholder):
    def __init__(self, name, DoB, gender, DoI, first_payment, pthly, term, increases):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.first_payment = first_payment
        self.term = term
        if np.isnan(increases):
            self.increases = 0
        else:
            self.increases = increases
    def PV_in(self, economy, superTable, date, DoDeath):
        return 0

    def PV_out(self, economy, superTable, date, DoDeath):
        if afterDeath(date, DoDeath):
            return 0
        else:
            age = date - self.DoB
            startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
            endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
            if np.isnan(startOffset) or np.isnan(endOffset):
                return 0
            interest = economy.interest(date)
            net_interest = interest - self.increases
            x = superTable.annuity(age, self.gender, startOffset, endOffset, interest, net_interest, self.pthly)
            x = x * self.first_payment * paymentIncrement(date + startOffset, self.DoI, self.pthly, self.increases) * self.pthly
            return x
    def PV(self, economy, lifeTable, date, DoDeath):
        return self.PV_in(economy, lifeTable, date, DoDeath) - self.PV_out(economy, lifeTable, date, DoDeath)

    def cashflows(self, economy, superTable, DoDeath):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        paymentDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        next_payment = self.first_payment * paymentIncrement(paymentDate, self.DoI, self.pthly, self.increases)
        lastDate = min([minDeath(endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly), DoDeath), economy.basis.projDate])
        if not(np.isnan(self.term)):
            last_date = math.min(lastDate, self.DoI + self.term)
        while paymentDate < lastDate:
            i = economy.basis.getIndex(paymentDate)
            cf[i] = cf[i] + next_payment
            paymentDate = paymentDate + 1 / self.pthly
            next_payment = next_payment * (1 + self.increases) ** (1/self.pthly)
        return cf


class Tbasis():
    def __init__(self, calcDate, projDate, interest, inflation, salary_incs, fwl, equity_mu, equity_sigma, interest_mu, interest_alpha, interest_sigma, inflation_mu, inflation_alpha, inflation_sigma, pthly):
        self.calcDate = date_in(calcDate)
        self.projDate = date_in(projDate)
        self.interest = interest
        self.inflation = inflation
        self.salary_incs = salary_incs
        self.fwl = fwl
        self.equity_mu = equity_mu    #maybe don't need this and just do a bespoke model in Teconomy
        self.equity_sigma = equity_sigma
        self.interest_mu = interest_mu
        self.interest_alpha = interest_alpha
        self.interest_sigma = interest_sigma
        self.inflation_mu = inflation_mu
        self.inflation_alpha = inflation_alpha
        self.inflation_sigma = inflation_sigma
        self.pthly = pthly
    def getIndex(self, date):
        zi = (date - self.calcDate) * self.pthly
        i = int(zi)
        return i

class Teconomy():
    def __init__(self, basis):
        self.basis = basis
        array_size = int((self.basis.projDate - self.basis.calcDate + 2) * self.basis.pthly)
        self.dates = np.zeros([array_size])
        self.zequities = np.zeros([array_size])
        self.zinterest = np.zeros([array_size])
        self.zinflation = np.zeros([array_size])
        i = 0
        self.dates[i] = self.basis.calcDate
        self.zequities[i] = 100
        self.zinterest[i] = self.basis.interest
        self.zinflation[i] = self.basis.inflation
        while self.dates[i] <= self.basis.projDate + 1:
            i = i + 1
            self.dates[i] = self.dates[i-1] + 1 / basis.pthly
            #the following is WRONG - it is the 'idiots' solution Ito's lemma
            r1 = np.random.normal(0, 1)
            r2 = np.random.normal(0,1)
            r3 = np.random.normal(0,1)
            self.zequities[i] = self.zequities[i-1] * (1 + basis.equity_mu/basis.pthly + r1 * basis.equity_sigma/math.sqrt(basis.pthly))
            self.zinterest[i] = self.zinterest[i-1] + basis.interest_alpha * (basis.interest_mu - self.zinterest[i-1]) / basis.pthly + basis.interest_sigma * r2 / math.sqrt(basis.pthly)
            self.zinflation[i] = self.zinflation[i - 1] + basis.inflation_alpha * (basis.inflation_mu - self.zinflation[i - 1]) / basis.pthly + basis.inflation_sigma * r2 / math.sqrt(basis.pthly)
    def equities(self, date):
        zi = (date - self.dates[0]) / (self.dates[1] - self.dates[0])
        i = int(zi)
        f = zi - i
        return self.zequities[i] * (1-f) + self.zequities[i+1] * f
    def interest(self, date):
        zi = (date - self.dates[0]) / (self.dates[1] - self.dates[0])
        i = int(zi)
        f = zi - i
        return  self.zinterest[i] * (1-f) + self.zinterest[1+i] * f
    def inflation(self, date):
        zi = (date - self.dates[0]) / (self.dates[1] - self.dates[0])
        i = int(zi)
        f = zi - i
        return  self.zinflation[i] * (1-f) + self.zinflation[1+i] * f

class TbalanceSheet():
    def __init__(self, cash, equities, bonds, bond_duration, asatDate):
        self.cash = cash
        self.equities = equities
        self.bonds = bonds
        self.bond_duration = bond_duration
        self.asatDate = asatDate

class TlifeCompany():
    def __init__(self, balanceSheet, rent, salaries, policyholders):
        self.balanceSheet = balanceSheet
        self.rent = rent
        self.salaries = salaries
        self.policyholders = policyholders
    def rollForward(self, lastBS, economy, cashflows, index):
        t = 1 / economy.basis.pthly
        date1 = economy.basis.calcDate + index * t
        date2 = date1 + t
        date12 = (date1 + date2)/2
        av_int = economy.interest(date12)
        newCash = lastBS.cash + (1 * av_int) ** t - cashflows[index] * (1 + av_int) ** (t / 2)
        newCash = newCash  - (self.rent + self.salaries) * t
        newEquities = lastBS.equities * economy.equities(date2) / economy.equities(date1)
        newBonds = lastBS.bonds * (1 - av_int) ** t
        int1 = economy.interest(date1)
        int2 = economy.interest(date2)
        d = self.balanceSheet.bond_duration
        newBonds = newBonds * ((1 + int1) ** d) / ((1 + int2) ** d)
        newBS = TbalanceSheet(newCash, newEquities, newBonds, d, date2)
        return newBS


def paymentIncrement(next_prem_date, DoI, pthly, increases):
    payment_index = math.ceil((next_prem_date - DoI) * pthly) #this is the number of payments that have been made
    increment = (1 + increases) ** (payment_index / pthly)
    return increment



def days_in_month(m,y):
    if m==2:
        if y%4 == 0:
            dim = 29   #dim is days in month
        else:
            dim = 28
    elif (m==4) or (m==6) or (m==9) or (m==11):
        dim = 30
    else:
        dim = 31
    return dim

def date_in(s):
    if type(s) == str:
        a = s.split("/")  #splits date data by the separator "/", returns s as an array
        d = int(a[0])     #takes the first element of the array a and converts to integer value, that is, the date
        m = int(a[1])     # month
        y = int(a[2])     # year
        rdate = y + (m-1)/12 +(d-1)/(12 * days_in_month(m,y))
    else:
        rdate = 0
    return rdate

def date_out(rdate):
    y = int(rdate)
    m_frac = rdate - y
    m = int((0.0001 + m_frac * 12) + 1)
    d_frac = rdate - y - (m-1)/12
    d = int(0.0001 + d_frac * 12 * days_in_month(m,y) + 1)
    s = datetime.datetime(y,m,d)
    return s

def rnd_exp(q):
    mu = -math.log(1 - q)
    y = random.random()
    t = -math.log(y) / mu
    return t

def afterDeath(date, DoDeath):  #The (boolean) function is assessing whether the date indicated is b4 or after DoD
    if np.isnan(DoDeath):
        return False
    elif DoDeath == 0:
        return False
    else:
        return date > DoDeath

def minDeath(date, DoDeath):
    if np.isnan(DoDeath):
        return date
    elif DoDeath == 0:
        return date
    else:
        return min([date, DoDeath])

def startDate(date, DoI, term, pthly): #this is effectively, when is the next payment
    if np.isnan(term):
        use_term = 100
    else:
        use_term = term
    if DoI + use_term < date:
        return float("NaN")    #if this is the value returned by a function, then the PV is zero, since no more payments come in
    elif date > DoI:
        n_pths = (date - DoI) * pthly
        frac = 1 - (n_pths - int(n_pths))
        rdate = date + frac/pthly
        if rdate >= DoI + use_term:
            return float("NaN")
        else:
            return date + frac / pthly
    else:
        return DoI

def endDate(date, DoI, term, pthly):
    if np.isnan(term):
        return date + 100
    if DoI + term < date:
        return float("NaN")
    else:
        return DoI + term

def read_policyholders(csvFile):
    policyholderData = pd.read_csv(csvFile)
    phList = []
    for iph in policyholderData.index:
        ph = policyholderData.loc[iph]
        if ph.loc["policy type"] == "term":
            new_ph = Tassured(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], ph.loc["premium"], ph.loc["pthly"], ph.loc["term"])
        elif ph.loc["policy type"] == "whole life":
            new_ph = Tassured(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], ph.loc["premium"], ph.loc["pthly"], float("NaN"))
        elif ph.loc["policy type"] == "annuity constant":
            new_ph = Tannuitant(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["first payment"], ph.loc["pthly"], ph.loc["term"], 0)
        elif ph.loc["policy type"] == "annuity fixed":
            new_ph = Tannuitant(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["first payment"], ph.loc["pthly"], ph.loc["term"], ph.loc["increases"])
        else:
            new_ph = None
        if new_ph != None:
            phList.append(new_ph)
    return phList

print(time1 := datetime.datetime.now())
print("Setting up life tables")
UK2019 = TsuperTable('Main life table 2018-2020', 'data\lifetable.xlsx', -0.1, 0.25, 0.001)
print("Reading policyholder data")
policyholderList = read_policyholders('data\policyHolders.csv')
print("Setting up main basis")
mainBasis = Tbasis('1/1/2024','1/1/2027', 0.04, 0.06, 0.08, 12, 0.08, 0.16, 0.05, 0.5, 0.01, 0.02, 0.5, 0.01, 12)
print("Running Economic projections and Death Matrix")
allEconomies = []
total_MC = 1000
deathMatrix = np.zeros([len(policyholderList), total_MC])
for i in range(total_MC):
    economy_run = Teconomy(mainBasis)
    allEconomies.append(economy_run)
    for iph in range(len(policyholderList)):
        ph = policyholderList[iph]
        DoD = ph.randomDeath(UK2019, mainBasis)
        deathMatrix[iph, i] = DoD

array_size = int((mainBasis.projDate + 2 - mainBasis.calcDate) * mainBasis.pthly)
balanceSheet = TbalanceSheet(1000000, 1000000, 4000000, 7, mainBasis.calcDate)
company = TlifeCompany(balanceSheet, 50000, 800000, policyholderList)
total_liability = np.zeros([total_MC])
total_cashflows = np.zeros([total_MC, array_size])
for isim in range(total_MC):
    for iph in range(len(policyholderList)):
        ph = policyholderList[iph]
        economy = allEconomies[isim]
        total_liability[isim] = total_liability[isim] + ph.PV(economy, UK2019, mainBasis.projDate, deathMatrix[iph, isim])
        add_cashflows = ph.cashflows(economy, UK2019, deathMatrix[iph, isim])
        total_cashflows[isim, : ] = np.add(total_cashflows[isim, :], add_cashflows)

BSMatrix = []
for isim in range(total_MC):
    BSMatrix.append([])
    BSMatrix[isim].append(company.balanceSheet)
    previousBS = company.balanceSheet
    index = 0
    economy = allEconomies[isim]
    cashflows = total_cashflows[isim, :]
    while mainBasis.calcDate + index / mainBasis.pthly <= mainBasis.projDate:
        newBS = company.rollForward(previousBS, economy, cashflows, index)
        BSMatrix[isim].append(newBS)
        previousBS = newBS
        index = index + 1

solvency = np.zeros([total_MC])
for isim in range(total_MC):
    balanceSheets = BSMatrix[isim]
    index = int((mainBasis.projDate - mainBasis.calcDate) * mainBasis.pthly)
    this_BS = balanceSheets[index]
    solvency[isim] = this_BS.cash + this_BS.equities + this_BS.bonds + total_liability[isim]

plt.hist(solvency, color = 'red', bins = 60)
plt.title('Solvency')
plt.ylabel('Freq')
plt.xlabel('Assets - Liabilities')
plt.show()

print(time2 := datetime.datetime.now())
print(time2 - time1)
