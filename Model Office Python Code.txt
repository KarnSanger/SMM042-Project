
import datetime
import random

import numpy as np
import pandas as pd
import math
import matplotlib.pyplot as plt
#import lifeActuary as la

class TbaseTable:
    def __init__(self, xlFile):
        temp = pd.read_excel(xlFile).to_numpy()
        self.lxm = np.append(temp[:, 1],[0,0])
        self.lxf = np.append(temp[:, 2], [0,0])
        self.age = temp[:,0]

    def lx(self, x, gender):  #0 - males, 1 - female
        if x >= 101:
            return 0
        if x < 0:
            return 100000
        x1 = int(x)
        x2 = x1 + 1
        if gender == 0:
            l1 = self.lxm[x1]
            l2 = self.lxm[x2]
        elif gender == 1:
            l1 = self.lxf[x1]
            l2 = self.lxf[x2]
        else:
            return None
        frac = x - x1
        lx_value = (1 - frac) * l1 + frac * l2
        return lx_value

    def tpx(self, t, x, gender):
        if x > 101:
            return 0
        return self.lx(x+t, gender)/self.lx(x, gender)

class TlifeTable:
    def __init__(self, baseTable, interest):
        self.interest = interest
        self.baseTable = baseTable
    def lx(self, x, gender):
        return self.baseTable.lx(x, gender)
    def tpx(self, t, x, gender):
        return self.baseTable.tpx(t, x, gender)
    def tqx(self, t, x, gender):
        return 1 - self.tpx(t, x, gender)
    def setup_annuities(self):
        self.anndotm = np.empty([102], dtype=float) #setting up an empty vector with 102 elements
        self.anndotm[101] = 0
        self.anndotf = np.empty([102], dtype=float)
        self.anndotf[101] = 0
        for x in range(100, -1, -1):
            self.anndotm[x] = 1 + self.anndotm[x + 1] * self.tpx(1, x, 0)/(1 + self.interest)
            self.anndotf[x] = 1 + self.anndotf[x + 1] * self.tpx(1, x, 1)/(1 + self.interest)
    def anndot(self, age, gender):
        if age > 101:
            return 1
        iage = int(age)
        fage = age - iage
        if gender == 0:
            ann = self.anndotm[iage] * (1-fage) + self.anndotm[iage+1] * fage
        else:
            ann = self.anndotf[iage] * (1-fage) + self.anndotf[iage+1] * fage
        return  ann

    def setup_assurances(self):
        self.asscapm = np.empty([102],dtype = float)
        self.asscapm[101] = 1/(1 + self.interest)
        self.asscapf = np.empty([102], dtype = float)
        self.asscapf[101] = 1/(1 + self.interest)
        for x in range(100, -1, -1):
            self.asscapm[x] = (self.asscapm[x+1] * self.tpx(1, x, 0)+(self.tqx(1, x, 0)))/(1+self.interest)
            self.asscapf[x] = (self.asscapf[x+1] * self.tpx(1, x, 0)+(self.tqx(1, x, 0)))/(1+self.interest)

    def asscap(self, age, gender):
        iage = int(age)
        if age >= 101:
            return 1   #instant death
        fage = age - iage
        if gender == 0:
            ass = self.asscapm[iage] * (1-fage) + self.asscapm[iage+1] * fage
        else:
            ass = self.asscapf[iage] * (1 - fage) + self.asscapf[iage + 1] * fage
        return ass

    def setup_jointannuities(self):
        self.annjoint = np.zeros((102,102), dtype= float)
        self.annjoint[101] = [0] * len(self.annjoint[0])
        for row in self.annjoint:
            row[-1] = 0
        for m in range(100, -1, -1):
            for f in range(100, -1, -1):
                self.annjoint[m, f] = 1 + self.annjoint[m + 1, f + 1] * (self.tpx(1, m, 0)*self.tpx(1,f,1)) / (1 + self.interest)

    def annjoint(self, age_1, age_2, gender):
        if age_1 or age_2 > 101:
            return 1
        iage_1 = int(age_1)
        iage_2 = int(age_2)
        fage_1 = age_1 - iage_1
        fage_2 = age_2 - iage_2
        if gender == 0:
            annjoint = (1-fage_1)*(1-fage_1) * self.annjoint[iage_1, iage_2] + fage_1*(1-fage_1)*self.annjoint[iage_1+1,iage_2] + (1-fage_1)*fage_2*self.annjoint[iage_1,iage_2+1] + fage_1*fage_2*self.annjoint[iage_1+1,iage_2+1]
        else:
            annjoint = (1-fage_1)*(1-fage_2) * self.annjoint[iage_2, iage_1] + fage_2*(1-fage_1)*self.annjoint[iage_2+1,iage_1] + (1-fage_2)*fage_1*self.annjoint[iage_2,iage_1+1] + fage_1*fage_2*self.annjoint[iage_2+1,iage_1+1]
        return annjoint


class TsuperTable:
    def __init__(self, name, xlFile, interest1, interest2, interestStep):
        self.name = name
        self.interest1 = interest1
        self.interest2 = interest2
        self.interestStep = interestStep
        self.baseTable = TbaseTable(xlFile)
        self.allTables = []
        print("Setup actuarial tables")
        for i in np.arange(interest1, interest2, interestStep):
            newTable = TlifeTable(self.baseTable, i)
            newTable.setup_annuities()
            newTable.setup_assurances()
            newTable.setup_jointannuities()
            self.allTables.append(newTable)
    def annuity(self, age, gender, startOffset, endOffset, pre_interest, interest, pthly):
        if interest < self.interest1:
            i_index = 0
        elif interest >= self.interest2 - self.interestStep * 2:
            fake_interest = self.interest2 - self.interestStep * 2
            i_index = int((fake_interest - self.interest1) / self.interestStep)
        else:
            i_index = int((interest - self.interest1) / self.interestStep)
        i1 = i_index * self.interestStep + self.interest1
        i2 = i1 + self.interestStep
        ifrac = (interest - i1)/(i2 - i1)
        table1 = self.allTables[i_index]
        table2 = self.allTables[i_index + 1]
        ageStart = age + startOffset
        lifeAnnuity_1 = table1.anndot(ageStart, gender)
        lifeAnnuity_2 = table2.anndot(ageStart, gender)
        n_payments = (endOffset - startOffset) * pthly
        n_payments = math.ceil(n_payments)
        ageEnd = age + startOffset + n_payments/pthly
        new_endOffset = ageEnd - age
        endAnnuity_1 = table1.anndot(ageEnd, gender)
        endAnnuity_2 = table2.anndot(ageEnd, gender)
        pthly_adjust = (pthly - 1)/(2 * pthly)
        lifeAnnuity = lifeAnnuity_1 * (1 - ifrac) + lifeAnnuity_2 * ifrac - pthly_adjust
        endAnnuity = endAnnuity_1 * (1 - ifrac) + endAnnuity_2 * ifrac - pthly_adjust
        startDiscount = table1.tpx(startOffset, age, gender)
        endDiscount = (1 + interest) ** (startOffset - new_endOffset) * table1.tpx(new_endOffset, age, gender)
        total_value = (1 + pre_interest) ** (-startOffset) * (startDiscount * (lifeAnnuity) - endDiscount * (endAnnuity))
        return total_value

    def assurance(self, age, gender, startOffset, endOffset, interest, deferral): #deferral is an average: 0 immediate, 0.5 end of the year. slightly inaccurate for non-integer terms
        if interest < self.interest1:
            i_index = 0
        elif interest >= self.interest2 - self.interestStep * 2:
            fake_interest = self.interest2 - self.interestStep * 2
            i_index = int((fake_interest-self.interest1)/self.interestStep)
        else:
            i_index = int((interest - self.interest1)/self.interestStep)
        i1 = i_index * self.interestStep + self.interest1
        i2 = i1 + self.interestStep
        ifrac = (interest - i1)/(i2 - i1)
        table1 = self.allTables[i_index]
        table2 = self.allTables[i_index + 1]
        ageStart = age + startOffset
        startAssurance_1 = table1.asscap(ageStart, gender)
        startAssurance_2 = table2.asscap(ageStart, gender)
        ageEnd = age + endOffset
        endAssurance_1 = table1.asscap(ageEnd, gender)
        endAssurance_2 = table2.asscap(ageEnd, gender)
        startAssurance = startAssurance_1 * (1 - ifrac) + startAssurance_2 * ifrac
        endAssurance = endAssurance_1 * (1- ifrac) + endAssurance_2 * ifrac
        startDiscount = (1 + interest) ** (-startOffset) * table1.tpx(startOffset, age, gender)
        endDiscount = (1 + interest) ** (-endOffset) * table1.tpx(endOffset, age, gender)
        total_value = startDiscount * startAssurance - endDiscount * endAssurance
        total_value = total_value * (1 + interest) ** (0.5 - deferral)
        return total_value

    def joint_annuity(self, age_1,age_2, gender, startOffset, endOffset, pre_interest, interest, pthly):
        if interest < self.interest1:
            i_index = 0
        elif interest >= self.interest2 - self.interestStep * 2:
            fake_interest = self.interest2 - self.interestStep * 2
            i_index = int((fake_interest - self.interest1) / self.interestStep)
        else:
            i_index = int((interest - self.interest1) / self.interestStep)
        i1 = i_index * self.interestStep + self.interest1
        i2 = i1 + self.interestStep
        ifrac = (interest - i1)/(i2 - i1)
        table1 = self.allTables[i_index]
        table2 = self.allTables[i_index + 1]
        ageStart_1 = age_1 + startOffset          #start age for policyholder
        ageStart_2 = age_2 + startOffset          #start age for Spouse
        jointlifeAnnuity_1 = table1.annjoint(ageStart_1, ageStart_2, gender)
        jointlifeAnnuity_2 = table2.annjoint(ageStart_1, ageStart_2, gender)
        n_payments = (endOffset - startOffset) * pthly
        n_payments = math.ceil(n_payments)
        ageEnd_1 = age_1 + startOffset + n_payments/pthly         #End age for policyholder
        ageEnd_2 = age_2 + startOffset + n_payments / pthly       #End age for spouse
        new_endOffset_1 = ageEnd_1 - age_1
        new_endOffset_2 = ageEnd_2 - age_2
        endjointAnnuity_1 = table1.annjoint(ageEnd_1, ageEnd_2, gender)
        endjointAnnuity_2 = table2.annjoint(ageEnd_1, ageEnd_2, gender)
        pthly_adjust = (pthly - 1)/(2 * pthly)
        jointlifeAnnuity = jointlifeAnnuity_1 * (1 - ifrac) + jointlifeAnnuity_2 * ifrac - pthly_adjust
        endjointAnnuity = endjointAnnuity_1 * (1 - ifrac) + endjointAnnuity_2 * ifrac - pthly_adjust
        if gender == 0:
            startDiscount = table1.tpx(startOffset, age_1, 0) * table1.tpx(startOffset, age_2, 1)
            endDiscount = (1 + interest) ** (startOffset - new_endOffset_1) * table1.tpx(new_endOffset_1, age_1, 0) * table1.tpx(new_endOffset_2, age_2, 1)
        else:
            startDiscount = table1.tpx(startOffset, age_1, 0) * table1.tpx(startOffset, age_2, 1)
            endDiscount = (1 + interest) ** (startOffset - new_endOffset_1) * table1.tpx(new_endOffset_1, age_1,0) * table1.tpx(new_endOffset_2, age_2, 1)
        total_value = (1 + pre_interest) ** (-startOffset) * (startDiscount * (jointlifeAnnuity) - endDiscount * (endjointAnnuity))
        return total_value
    def lx(self, x, gender):
        return self.baseTable.lx(x, gender)
    def tpx(self, t, x, gender):
        return self.baseTable.tpx(t, x, gender)
    def tqx(self, t, x, gender):
        return 1 - self.baseTable.tpx(t, x, gender)

class Tperson:
    def __init__(self, name, DoB, gender):
        self.name = name
        self.DoB = date_in(DoB)
        self.gender = gender

    def randomDeath(self, lifeTable, basis):
        age = basis.calcDate - self.DoB
        iage = int(age)
        age1 = age
        age2 = iage + 1
        while age1 < basis.projDate - basis.calcDate + age:  #return actual date of death
            q_age = lifeTable.tqx(1, iage, self.gender)
            rnd_death = rnd_exp(q_age)
            if rnd_death < age2 - age1:
                return rnd_death + age1 + self.DoB
            age1 = age2
            age2 = age2 + 1
            iage = int(age1)
        return float("NaN")

    def lapse(self, lapse_first_year, lapse_subsequent_years, basis):    # generate random date of lapse
        # checks that the policy has started
        if self.DoI > basis.calcDate and self.DoI < basis.projDate:
            age = self.DoI - self.DoB
        elif self.DoI < basis.calcDate and self.DoI < basis.projDate:
            age = basis.calcDate - self.DoB
        else:
            return float("NaN")
        age1 = age
        while age1 < age + 1:
            rnd_lapse = rnd_exp_lapse(lapse_first_year)
            if rnd_lapse < 1:
                return rnd_lapse + age + self.DoB
            age1 = age1 + 1
        if self.DoI > basis.calcDate and self.DoI < basis.projDate:
            while age1 >= age + 1 and age1 < basis.projDate - self.DoI + age:
                rnd_lapse = rnd_exp_lapse(lapse_subsequent_years)
                if rnd_lapse > 1 and rnd_lapse < basis.projDate - self.DoI:
                    return rnd_lapse + age + self.DoB
                age1 = age1 + 1
            return float("NaN")
        else:
            while age1 >= age + 1 and age1 < basis.projDate - basis.calcDate + age:
                rnd_lapse = rnd_exp_lapse(lapse_subsequent_years)
                if rnd_lapse > 1 and rnd_lapse < basis.projDate - basis.calcDate:
                    return rnd_lapse + age + self.DoB
                age1 = age1 + 1
            return float("NaN")


class Tpolicyholder(Tperson):
    def __init__(self, name, DoB, gender, DoI, pthly):
        Tperson.__init__(self, name, DoB, gender)
        self.DoI = date_in(DoI)
        self.pthly = pthly  #this refers to the premium for assured lives and payment for annuitants
    def PV(self, economy, superTable, date, DoDeath,DoLapse):
        print("Attempting to calculate PV for abstract class")
        return  0
    def cashflows(self, economy, lifeTable, DoDeath,DoLapse):
        print("Attempting to calculate cashflows for abstract class")
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        return cf

class Tassured(Tpolicyholder):
    def __init__(self,name, DoB, gender, DoI, SA, gteed, premium, pthly, term):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.term = term
        self.premium = premium
        if np.isnan(gteed):
            self.gteed = 0
        else:
            self.gteed = gteed
        if np.isnan(SA):
            self.SA = 0
        else:
            self.SA = SA

    def PV_out(self, economy, superTable, date, DoDeath, DoLapse):
        if afterDeath(date, DoDeath):
            return 0
        if afterLapse(date, DoLapse):
            return 0
        else:
            age = date - self.DoB
            startOffset = max([0, self.DoI - date])
            if np.isnan(self.term):
                endOffset = 100
            else:
                endOffset = self.DoI - date + self.term
            if endOffset < 0:
                return 0
            interest = economy.interest(date)
            deferral = 0
            x_assured = superTable.assurance(age, self.gender, startOffset, endOffset, interest, deferral)  # to compute term assurance for both term and EA
            x_pure_endowment = superTable.tpx(endOffset, age, self.gender) * (1 + interest) ** (-endOffset)  # to compute Pure Endowment
            x = x_assured * self.SA + x_pure_endowment * self.gteed
            return x
    def PV_in(self, economy, superTable, date, DoDeath,DoLapse):
            if afterDeath(date, DoDeath):
                return 0
            if afterLapse(date, DoLapse):
                return 0
            else:
                age = date - self.DoB
                startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
                endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
                if np.isnan(startOffset) or np.isnan(endOffset):
                    return 0
                interest = economy.interest(date)
                x = superTable.annuity(age, self.gender, startOffset, endOffset, interest, interest, self.pthly)
                x = x * self.premium * self.pthly
                return x
    def PV(self, economy, superTable, date, DoDeath,DoLapse):
        return self.PV_in(economy, superTable, date, DoDeath,DoLapse) - self.PV_out(economy, superTable, date, DoDeath,DoLapse)
    def cashflows(self, economy, superTable, DoDeath, DoLapse):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        premDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        endTermDate = endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        lastDate = min([minLapse(minDeath(endTermDate, DoDeath),DoLapse), economy.basis.projDate])
        if np.isnan(premDate) or np.isnan(lastDate):
            return cf
        if afterDeath( min(endTermDate, economy.basis.projDate), DoDeath):
            cf[economy.basis.getIndex(DoDeath)] = -self.SA
        if afterLapse(min(endTermDate, economy.basis.projDate), DoLapse):
            cf[economy.basis.getIndex(DoLapse)] = 0
        while premDate < lastDate:
            i = economy.basis.getIndex(premDate)
            cf[i] = cf[i] + self.premium
            premDate = premDate + 1 / self.pthly
        return cf

class TEndowment(Tpolicyholder):
    def __init__(self,name, DoB, gender, DoI, SA, gteed, premium, pthly, term):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.term = term
        self.premium = premium
        self.gteed = gteed
        if np.isnan(SA):
            self.SA = 0
        else:
            self.SA = SA

    def PV_out(self, economy, superTable, date, DoDeath, DoLapse):
        if afterDeath(date, DoDeath):
            return 0
        else:
            age = date - self.DoB
            startOffset = max([0, self.DoI - date])
            if np.isnan(self.term):
                endOffset = 100
            else:
                endOffset = self.DoI - date + self.term
            if endOffset < 0:
                return 0
            interest = economy.interest(date)
            deferral = 0
            x_assured = superTable.assurance(age, self.gender, startOffset, endOffset, interest, deferral)  # to compute term assurance for both term and EA
            x_pure_endowment = superTable.tpx(endOffset, age, self.gender) * (1 + interest) ** (-endOffset)  # to compute Pure Endowment
            x = x_assured * self.SA + x_pure_endowment * self.gteed
            return x
    def PV_in(self, economy, superTable, date, DoDeath,DoLapse):
            if afterDeath(date, DoDeath):
                return 0
            else:
                age = date - self.DoB
                startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
                endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
                if np.isnan(startOffset) or np.isnan(endOffset):
                    return 0
                interest = economy.interest(date)
                x = superTable.annuity(age, self.gender, startOffset, endOffset, interest, interest, self.pthly)
                x = x * self.premium * self.pthly
                return x
    def PV(self, economy, superTable, date, DoDeath,DoLapse):
        return self.PV_in(economy, superTable, date, DoDeath,DoLapse) - self.PV_out(economy, superTable, date, DoDeath,DoLapse)
    def cashflows(self, economy, superTable, DoDeath, DoLapse):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        premDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        endTermDate = endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        lastDate = min([minDeath(endTermDate, DoDeath), economy.basis.projDate])
        if np.isnan(premDate) or np.isnan(lastDate):
            return cf
        if afterDeath( min(endTermDate, economy.basis.projDate), DoDeath):
            cf[economy.basis.getIndex(DoDeath)] = -self.SA
        while premDate < lastDate:
            i = economy.basis.getIndex(premDate)
            cf[i] = cf[i] + self.premium
            premDate = premDate + 1 / self.pthly
        return cf

class TassuredJoint(Tpolicyholder):
    def __init__(self,name, DoB, gender, DoI, SA, premium, pthly, term, Spouse_DoB):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.SA = SA
        self.term = term
        self.premium = premium
        self.Spouse_DoB = date_in(Spouse_DoB)

    def PV_out(self, economy, superTable, date, DoDeath,DoLapse):
        if afterDeath(date, DoDeath):
            return 0
        else:
            age_ph = date - self.DoB
            age_spouse = date - self.Spouse_DoB
            startOffset = max([0, self.DoI - date])
            if np.isnan(self.term):
                endOffset = 100
            else:
                endOffset = self.DoI - date + self.term
            if endOffset < 0:
                return 0
            interest = economy.interest(date)
            deferral = 0
            x_jointassured = superTable.joint_annuity(age_ph, age_spouse, self.gender, startOffset, endOffset, interest,interest,self.pthly) * interest/(1+interest)
            x = x_jointassured * self.SA
            return x
    def PV_in(self, economy, superTable, date, DoDeath,DoLapse):
            if afterDeath(date, DoDeath):
                return 0
            else:
                age_ph = date - self.DoB
                age_spouse = date - self.Spouse_DoB
                startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
                endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
                if np.isnan(startOffset) or np.isnan(endOffset):
                    return 0
                interest = economy.interest(date)
                x = 1 - superTable.joint_annuity(age_ph, age_spouse, self.gender, startOffset, endOffset, interest,interest,self.pthly)
                x = x * self.premium * self.pthly
                return x
    def PV(self, economy, superTable, date, DoDeath,DoLapse):
        return self.PV_in(economy, superTable, date, DoDeath,DoLapse) - self.PV_out(economy, superTable, date, DoDeath,DoLapse)
    def cashflows(self, economy, superTable, DoDeath,DoLapse):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        premDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        endTermDate = endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        lastDate = min([minDeath(endTermDate, DoDeath), economy.basis.projDate])
        if np.isnan(premDate) or np.isnan(lastDate):
            return cf
        if afterDeath( min(endTermDate, economy.basis.projDate), DoDeath):
            cf[economy.basis.getIndex(DoDeath)] = -self.SA
        while premDate < lastDate:
            i = economy.basis.getIndex(premDate)
            cf[i] = cf[i] + self.premium
            premDate = premDate + 1 / self.pthly
        return cf

class TassuredLS(Tpolicyholder):
    def __init__(self,name, DoB, gender, DoI, SA, premium, pthly, term, Spouse_DoB):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.SA = SA
        self.term = term
        self.premium = premium
        self.Spouse_DoB = date_in(Spouse_DoB)

    def PV_out(self, economy, superTable, date, DoDeath,DoLapse):
        if afterDeath(date, DoDeath):
            return 0
        else:
            age_ph = date - self.DoB
            age_spouse = date - self.Spouse_DoB
            startOffset = max([0, self.DoI - date])
            if np.isnan(self.term):
                endOffset = 100
            else:
                endOffset = self.DoI - date + self.term
            if endOffset < 0:
                return 0
            interest = economy.interest(date)
            deferral = 0
            if self.gender ==0:
                x_LS = superTable.assurance(age_ph, 0, startOffset, endOffset, interest, deferral) + superTable.assurance(age_spouse, 1, startOffset, endOffset, interest, deferral) -(1 - superTable.joint_annuity(age_ph, age_spouse, self.gender, startOffset, endOffset, interest,interest,self.pthly) * interest/(1+interest))
            else:
                x_LS = superTable.assurance(age_ph, 1, startOffset, endOffset, interest, deferral) + superTable.assurance(age_spouse, 0, startOffset,endOffset, interest, deferral) - (1 - superTable.joint_annuity(age_ph, age_spouse, self.gender, startOffset, endOffset,interest, interest, self.pthly) * interest / (1 + interest))
            x = x_LS * self.SA
            return x
    def PV_in(self, economy, superTable, date, DoDeath,DoLapse):
            if afterDeath(date, DoDeath):
                return 0
            else:
                age_ph = date - self.DoB
                age_spouse = date - self.Spouse_DoB
                startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
                endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
                if np.isnan(startOffset) or np.isnan(endOffset):
                    return 0
                interest = economy.interest(date)
                if self.gender == 0:
                    x = TsuperTable.annuity(age_ph, self.gender, startOffset, endOffset, interest, interest, self.pthly) + superTable.annuity(age_spouse, 1, startOffset, endOffset, interest, interest, self.pthly) - superTable.joint_annuity(age_ph, age_spouse, self.gender, startOffset, endOffset, interest,interest,self.pthly)
                else:
                    x = TsuperTable.annuity(age_ph, self.gender, startOffset, endOffset, interest, interest, self.pthly) + superTable.annuity(age_spouse, 0, startOffset, endOffset, interest, interest, self.pthly) - superTable.joint_annuity(age_ph, age_spouse, self.gender, startOffset, endOffset, interest,interest,self.pthly)
                x = x * self.premium * self.pthly
                return x
    def PV(self, economy, superTable, date, DoDeath,DoLapse):
        return self.PV_in(economy, superTable, date, DoDeath,DoLapse) - self.PV_out(economy, superTable, date, DoDeath,DoLapse)
    def cashflows(self, economy, superTable, DoDeath,DoLapse):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        premDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        endTermDate = endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        lastDate = min([minDeath(endTermDate, DoDeath), economy.basis.projDate])
        if np.isnan(premDate) or np.isnan(lastDate):
            return cf
        if afterDeath( min(endTermDate, economy.basis.projDate), DoDeath):
            cf[economy.basis.getIndex(DoDeath)] = -self.SA
        while premDate < lastDate:
            i = economy.basis.getIndex(premDate)
            cf[i] = cf[i] + self.premium
            premDate = premDate + 1 / self.pthly
        return cf

class Tannuitant(Tpolicyholder):
    def __init__(self, name, DoB, gender, DoI, first_payment, pthly, term, increases):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.first_payment = first_payment
        self.term = term
        if np.isnan(increases):
            self.increases = 0
        else:
            self.increases = increases
    def PV_in(self, economy, superTable, date, DoDeath,DoLapse):
        return 0

    def PV_out(self, economy, superTable, date, DoDeath,DoLapse):
        if afterDeath(date, DoDeath):
            return 0
        else:
            age = date - self.DoB
            startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
            endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
            if np.isnan(startOffset) or np.isnan(endOffset):
                return 0
            interest = economy.interest(date)
            net_interest = interest - self.increases
            x = superTable.annuity(age, self.gender, startOffset, endOffset, interest, net_interest, self.pthly)
            x = x * self.first_payment * paymentIncrement(date + startOffset, self.DoI, self.pthly, self.increases) * self.pthly
            return x
    def PV(self, economy, lifeTable, date, DoDeath,DoLapse):
        return self.PV_in(economy, lifeTable, date, DoDeath,DoLapse) - self.PV_out(economy, lifeTable, date, DoDeath,DoLapse)

    def cashflows(self, economy, superTable, DoDeath, DoLapse):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        paymentDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        next_payment = self.first_payment * paymentIncrement(paymentDate, self.DoI, self.pthly, self.increases)
        lastDate = min([minDeath(endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly), DoDeath), economy.basis.projDate])
        if not(np.isnan(self.term)):
            last_date = math.min(lastDate, self.DoI + self.term)
        while paymentDate < lastDate:
            i = economy.basis.getIndex(paymentDate)
            cf[i] = cf[i] + next_payment
            paymentDate = paymentDate + 1 / self.pthly
            next_payment = next_payment * (1 + self.increases) ** (1/self.pthly)
        return cf


class Tjointannuitant(Tpolicyholder):
    def __init__(self, name, DoB, gender, DoI, first_payment, pthly, term, increases, Spouse_DoB, spouse_prop):
        Tpolicyholder.__init__(self, name, DoB, gender, DoI, pthly)
        self.first_payment = first_payment
        self.term = term
        self.Spouse_DoB = date_in(Spouse_DoB)
        self.spouse_prop = spouse_prop
        if np.isnan(increases):
            self.increases = 0
        else:
            self.increases = increases

    def randomDeathJointannuity(self, lifeTable, basis):
        age_ph = basis.calcDate - self.DoB
        age_spouse = basis.calcDate - self.SpouseDoB
        iage_ph = int(age_ph)
        iage_spouse = int(age_spouse)
        age1_ph = age_ph
        age2_ph = iage_ph + 1
        age1_spouse = age_spouse
        age2_spouse = iage_spouse + 1
        while age1_ph < basis.projDate - basis.calcDate + age_ph and age1_spouse < basis.projDate - basis.calcDate + age_spouse:  #return actual date of death
            if self.gender == 0:
                q_age = 1-lifeTable.tpx(1, iage_ph, self.gender) * lifeTable.tpx(1, iage_spouse, 1)  #probability of failure of the joint life status
            else:
                q_age = 1-lifeTable.tpx(1, iage_ph, self.gender) * lifeTable.tpx(1, iage_spouse, 0)
            rnd_death = rnd_exp(q_age)
            if rnd_death < age2_ph - age1_ph:
                return rnd_death + age1_ph + self.DoB
            elif rnd_death < age2_spouse - age1_spouse:
                return rnd_death + age1_spouse + self.Spouse_DoB

            age1_ph = age2_ph
            age1_spouse = age2_spouse
            age2_ph = age2_ph + 1
            age2_spouse = age2_spouse + 1
            iage_ph = int(age1_ph)
            iage_spouse = int(age1_spouse)

        return float("NaN")


    def PV_in(self, economy, superTable, date, DoDeath,DoLapse):
        return 0

    def PV_out(self, economy, superTable, date, DoDeath,DoLapse):
        if afterDeath(date, DoDeath):
            return 0
        else:
            age_1 = date - self.DoB
            age_2 = date - self.Spouse_DoB
            startOffset = startDate(date, self.DoI, self.term, self.pthly) - date
            endOffset = endDate(date, self.DoI, self.term, self.pthly) - date
            if np.isnan(startOffset) or np.isnan(endOffset):
                return 0
            interest = economy.interest(date)
            net_interest = interest - self.increases
            x = superTable.annuity(age_1, self.gender, startOffset, endOffset, interest, net_interest, self.pthly)
            x = x * self.first_payment * paymentIncrement(date + startOffset, self.DoI, self.pthly, self.increases) * self.pthly
            return x
    def PV(self, economy, lifeTable, date, DoDeath,DoLapse):
        return self.PV_in(economy, lifeTable, date, DoDeath,DoLapse) - self.PV_out(economy, lifeTable, date, DoDeath,DoLapse)

    def cashflows(self, economy, superTable, DoDeath,DoLapse):  #Economy contains a basis which has start, end and pthly. DoDeath is from the deathMatrix
        array_size = int((economy.basis.projDate + 2 - economy.basis.calcDate) * economy.basis.pthly)
        cf = np.zeros([array_size])
        paymentDate = startDate(economy.basis.calcDate, self.DoI, self.term, self.pthly)
        next_payment = self.first_payment * paymentIncrement(paymentDate, self.DoI, self.pthly, self.increases)
        lastDate = min([minDeath(endDate(economy.basis.calcDate, self.DoI, self.term, self.pthly), DoDeath), economy.basis.projDate])
        if not(np.isnan(self.term)):
            last_date = math.min(lastDate, self.DoI + self.term)
        while paymentDate < lastDate:
            i = economy.basis.getIndex(paymentDate)
            cf[i] = cf[i] + next_payment
            paymentDate = paymentDate + 1 / self.pthly
            next_payment = next_payment * (1 + self.increases) ** (1/self.pthly)
        return cf

class Tbasis():
    def __init__(self, calcDate, projDate, interest, inflation, salary_incs, fwl, equity_mu, equity_sigma, interest_mu, interest_alpha, interest_sigma, inflation_mu, inflation_alpha, inflation_sigma, pthly):
        self.calcDate = date_in(calcDate)
        self.projDate = date_in(projDate)
        self.interest = interest
        self.inflation = inflation
        self.salary_incs = salary_incs
        self.fwl = fwl
        self.equity_mu = equity_mu    #maybe don't need this and just do a bespoke model in Teconomy
        self.equity_sigma = equity_sigma
        self.interest_mu = interest_mu
        self.interest_alpha = interest_alpha
        self.interest_sigma = interest_sigma
        self.inflation_mu = inflation_mu
        self.inflation_alpha = inflation_alpha
        self.inflation_sigma = inflation_sigma
        self.pthly = pthly
    def getIndex(self, date):
        zi = (date - self.calcDate) * self.pthly
        i = int(zi)
        return i

class Teconomy():
    def __init__(self, basis):
        self.basis = basis
        array_size = int((self.basis.projDate - self.basis.calcDate + 2) * self.basis.pthly)
        self.dates = np.zeros([array_size])
        self.zequities = np.zeros([array_size])
        self.zinterest = np.zeros([array_size])
        self.zinflation = np.zeros([array_size])
        i = 0
        self.dates[i] = self.basis.calcDate
        self.zequities[i] = 100
        self.zinterest[i] = self.basis.interest
        self.zinflation[i] = self.basis.inflation
        while self.dates[i] <= self.basis.projDate + 1:
            i = i + 1
            self.dates[i] = self.dates[i-1] + 1 / basis.pthly
            #the following is WRONG - it is the 'idiots' solution Ito's lemma
            r1 = np.random.normal(0, 1)
            r2 = np.random.normal(0,1)
            r3 = np.random.normal(0,1)
            self.zequities[i] = self.zequities[i-1] * (1 + basis.equity_mu/basis.pthly + r1 * basis.equity_sigma/math.sqrt(basis.pthly))
            self.zinterest[i] = self.zinterest[i-1] + basis.interest_alpha * (basis.interest_mu - self.zinterest[i-1]) / basis.pthly + basis.interest_sigma * r2 / math.sqrt(basis.pthly)
            self.zinflation[i] = self.zinflation[i - 1] + basis.inflation_alpha * (basis.inflation_mu - self.zinflation[i - 1]) / basis.pthly + basis.inflation_sigma * r3 / math.sqrt(basis.pthly)
    def equities(self, date):
        zi = (date - self.dates[0]) / (self.dates[1] - self.dates[0])
        i = int(zi)
        f = zi - i
        return self.zequities[i] * (1-f) + self.zequities[i+1] * f
    def interest(self, date):
        zi = (date - self.dates[0]) / (self.dates[1] - self.dates[0])
        i = int(zi)
        f = zi - i
        return  self.zinterest[i] * (1-f) + self.zinterest[1+i] * f
    def inflation(self, date):
        zi = (date - self.dates[0]) / (self.dates[1] - self.dates[0])
        i = int(zi)
        f = zi - i
        return  self.zinflation[i] * (1-f) + self.zinflation[1+i] * f

class TbalanceSheet():
    def __init__(self, cash, equities, bonds, bond_duration, asatDate):
        self.cash = cash
        self.equities = equities
        self.bonds = bonds
        self.bond_duration = bond_duration
        self.asatDate = asatDate

class TlifeCompany():
    def __init__(self, balanceSheet, rent, salaries, policyholders):
        self.balanceSheet = balanceSheet
        self.rent = rent
        self.salaries = salaries
        self.policyholders = policyholders
    def rollForward(self, lastBS, economy, cashflows, index):
        t = 1 / economy.basis.pthly
        date1 = economy.basis.calcDate + index * t
        date2 = date1 + t
        date12 = (date1 + date2)/2
        av_int = economy.interest(date12)
        newCash = lastBS.cash + (1 * av_int) ** t - cashflows[index] * (1 + av_int) ** (t / 2)
        newCash = newCash  - (self.rent + self.salaries) * t
        newEquities = lastBS.equities * economy.equities(date2) / economy.equities(date1)
        newBonds = lastBS.bonds * (1 - av_int) ** t
        int1 = economy.interest(date1)
        int2 = economy.interest(date2)
        d = self.balanceSheet.bond_duration
        newBonds = newBonds * ((1 + int1) ** d) / ((1 + int2) ** d)
        newBS = TbalanceSheet(newCash, newEquities, newBonds, d, date2)
        return newBS


def paymentIncrement(next_prem_date, DoI, pthly, increases):
    payment_index = math.ceil((next_prem_date - DoI) * pthly) #this is the number of payments that have been made
    increment = (1 + increases) ** (payment_index / pthly)
    return increment



def days_in_month(m,y):
    if m==2:
        if y%4 == 0:
            dim = 29   #dim is days in month
        else:
            dim = 28
    elif (m==4) or (m==6) or (m==9) or (m==11):
        dim = 30
    else:
        dim = 31
    return dim

def date_in(s):
    if type(s) == str:
        a = s.split("/")  #splits date data by the separator "/", returns s as an array
        d = int(a[0])     #takes the first element of the array a and converts to integer value, that is, the date
        m = int(a[1])     # month
        y = int(a[2])     # year
        rdate = y + (m-1)/12 +(d-1)/(12 * days_in_month(m,y))
    else:
        rdate = 0
    return rdate

def date_out(rdate):
    y = int(rdate)
    m_frac = rdate - y
    m = int((0.0001 + m_frac * 12) + 1)
    d_frac = rdate - y - (m-1)/12
    d = int(0.0001 + d_frac * 12 * days_in_month(m,y) + 1)
    s = datetime.datetime(y,m,d)
    return s

def rnd_exp(q):
    mu = -math.log(1 - q)
    y = random.random()
    t = -math.log(y) / mu
    return t

def rnd_exp_lapse(l):
    mu = l
    y = random.random()
    t = -math.log(y) / mu
    return t
def afterDeath(date, DoDeath):  #The (boolean) function is assessing whether the date indicated is b4 or after DoD
    if np.isnan(DoDeath):
        return False
    elif DoDeath == 0:
        return False
    else:
        return date > DoDeath

def afterLapse(date, DoLapse):  #The (boolean) function is assessing whether the date indicated is b4 or after DoL
    if np.isnan(DoLapse):
        return False
    elif DoLapse == 0:
        return False
    else:
        return date > DoLapse

def minDeath(date, DoDeath):
    if np.isnan(DoDeath):
        return date
    elif DoDeath == 0:
        return date
    else:
        return min([date, DoDeath])

def minLapse(date, DoLapse):
    if np.isnan(DoLapse):
        return date
    elif DoLapse == 0:
        return date
    else:
        return min([date, DoLapse])

def startDate(date, DoI, term, pthly): #this is effectively, when is the next payment
    if np.isnan(term):
        use_term = 100
    else:
        use_term = term
    if DoI + use_term < date:
        return float("NaN")    #if this is the value returned by a function, then the PV is zero, since no more payments come in
    elif date > DoI:
        n_pths = (date - DoI) * pthly
        frac = 1 - (n_pths - int(n_pths))
        rdate = date + frac/pthly
        if rdate >= DoI + use_term:
            return float("NaN")
        else:
            return date + frac / pthly
    else:
        return DoI

def endDate(date, DoI, term, pthly):
    if np.isnan(term):
        return date + 100
    if DoI + term < date:
        return float("NaN")
    else:
        return DoI + term

def read_policyholders(csvFile):
    policyholderData = pd.read_csv(csvFile)
    phList = []
    for iph in policyholderData.index:
        ph = policyholderData.loc[iph]
        if ph.loc["policy type"] == "term":
            new_ph = Tassured(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"],float("NaN") ,ph.loc["premium"], ph.loc["pthly"], ph.loc["term"])
        elif ph.loc["policy type"] == "whole life":
            new_ph = Tassured(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], float("NaN"), ph.loc["premium"], ph.loc["pthly"], float("NaN"))
        elif ph.loc["policy type"] == "annuity constant":
            new_ph = Tannuitant(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["first payment"], ph.loc["pthly"], ph.loc["term"], 0)
        elif ph.loc["policy type"] == "annuity fixed":
            new_ph = Tannuitant(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["first payment"], ph.loc["pthly"], ph.loc["term"], ph.loc["increases"])
        elif ph.loc["policy type"] == "endowment":
            new_ph = TEndowment(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], ph.loc["gteed amount"] ,ph.loc["premium"], ph.loc["pthly"], ph.loc["term"])
        elif ph.loc["policy type"] == "endowment assurance":
            new_ph = TEndowment(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], ph.loc["gteed amount"] ,ph.loc["premium"], ph.loc["pthly"], ph.loc["term"])
        #elif ph.loc["policy type"] == "annuity fixed + spouse":
            #new_ph = Tjointannuitant(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["first payment"], ph.loc["pthly"], ph.loc["term"], ph.loc["increases"], ph.loc["Spouse DoB"], ph.loc["Spouse prop"])
        elif ph.loc["policy type"] == "whole life first death":
            new_ph = TassuredJoint(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], ph.loc["premium"], ph.loc["pthly"], float("NaN"), ph.loc["Spouse DoB"])
        elif ph.loc["policy type"] == "whole life second death":
            new_ph = TassuredLS(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], ph.loc["premium"], ph.loc["pthly"], float("NaN"), ph.loc["Spouse DoB"])
        elif ph.loc["policy type"] == "term first death":
            new_ph = TassuredJoint(ph.loc["name"], ph.loc["DoB"], ph.loc["gender"], ph.loc["DoI"], ph.loc["SA"], ph.loc["premium"], ph.loc["pthly"], ph.loc["term"], ph.loc["Spouse DoB"])
        else:
            new_ph = None
        if new_ph != None:
            phList.append(new_ph)
    return phList

print(time1 := datetime.datetime.now())
print("Setting up life tables")
UK2019 = TsuperTable('Main life table 2018-2020', 'data\lifetable.xlsx', -0.1, 0.25, 0.001)
print("Reading policyholder data")
policyholderList = read_policyholders('data\policyHolders.csv')
print("Setting up main basis")
mainBasis = Tbasis('1/1/2024','1/1/2027', 0.04, 0.06, 0.08, 12, 0.08, 0.16, 0.05, 0.5, 0.01, 0.02, 0.5, 0.01, 12)
print("Running Economic projections and Death Matrix")
allEconomies = []
total_MC = 1000
deathMatrix = np.zeros([len(policyholderList), total_MC])
for i in range(total_MC):
    economy_run = Teconomy(mainBasis)
    allEconomies.append(economy_run)
    for iph in range(len(policyholderList)):
        ph = policyholderList[iph]
        DoD = ph.randomDeath(UK2019, mainBasis)
        deathMatrix[iph, i] = DoD

lapseMatrix = np.zeros([len(policyholderList), total_MC])
for i in range(total_MC):
    economy_run = Teconomy(mainBasis)
    allEconomies.append(economy_run)
    for iph in range(len(policyholderList)):
        ph = policyholderList[iph]
        DoL = ph.lapse(0.05,0.02, mainBasis)
        lapseMatrix[iph, i] = DoL



array_size = int((mainBasis.projDate + 2 - mainBasis.calcDate) * mainBasis.pthly)
balanceSheet = TbalanceSheet(1000000, 1000000, 4000000, 7, mainBasis.calcDate)
company = TlifeCompany(balanceSheet, 50000, 800000, policyholderList)
total_liability = np.zeros([total_MC])
total_cashflows = np.zeros([total_MC, array_size])
for isim in range(total_MC):
    for iph in range(len(policyholderList)):
        ph = policyholderList[iph]
        economy = allEconomies[isim]
        total_liability[isim] = total_liability[isim] + ph.PV(economy, UK2019, mainBasis.projDate, deathMatrix[iph, isim] ,lapseMatrix[iph, isim])
        add_cashflows = ph.cashflows(economy, UK2019, deathMatrix[iph, isim], lapseMatrix[iph, isim])
        total_cashflows[isim, : ] = np.add(total_cashflows[isim, :], add_cashflows)

BSMatrix = []
for isim in range(total_MC):
    BSMatrix.append([])
    BSMatrix[isim].append(company.balanceSheet)
    previousBS = company.balanceSheet
    index = 0
    economy = allEconomies[isim]
    cashflows = total_cashflows[isim, :]
    while mainBasis.calcDate + index / mainBasis.pthly <= mainBasis.projDate:
        newBS = company.rollForward(previousBS, economy, cashflows, index)
        BSMatrix[isim].append(newBS)
        previousBS = newBS
        index = index + 1

solvency = np.zeros([total_MC])
for isim in range(total_MC):
    balanceSheets = BSMatrix[isim]
    index = int((mainBasis.projDate - mainBasis.calcDate) * mainBasis.pthly)
    this_BS = balanceSheets[index]
    solvency[isim] = this_BS.cash + this_BS.equities + this_BS.bonds + total_liability[isim]

plt.hist(solvency, color = 'red', bins = 60)
plt.title('Solvency')
plt.ylabel('Freq')
plt.xlabel('Assets - Liabilities')
plt.show()

print(time2 := datetime.datetime.now())
print(time2 - time1)


#     # Initialize cash level
initial_balance_sheet = BSMatrix[0][0]
cash_allocation = 0.1
equities_allocation = 0.3
bonds_allocation = 0.6

# Obtain the initial values of cash, equities, and bonds
initial_cash = initial_balance_sheet.cash
initial_equities = initial_balance_sheet.equities
initial_bonds = initial_balance_sheet.bonds
# Calculate the initial portfolio value
initial_portfolio_value = initial_cash + initial_equities + initial_bonds

cash = 0.10 * initial_portfolio_value

# Define the rebalancing dates and thresholds
rebalance_dates = [mainBasis.calcDate]  # Initialize with the starting date
rebalance_month = mainBasis.calcDate.month

from datetime import timedelta
for i in range(int((mainBasis.projDate - mainBasis.calcDate).days)):
    current_date = mainBasis.calcDate + timedelta(days=i)
   
# Check for end-of-year rebalancing
if current_date.month == 1 and rebalance_month != 1:
    rebalance_month = 1
    rebalance_dates.append(current_date)
   
# Check for monthly rebalancing based on cash threshold
if (current_date.month != rebalance_month) and (cash / initial_portfolio_value < cash_allocation):
    rebalance_month = current_date.month
    rebalance_dates.append(current_date)

# Perform the investment strategy for each simulation
for isim in range(total_MC):
    balanceSheet = TbalanceSheet(initial_portfolio_value, initial_portfolio_value, 0, 7, mainBasis.calcDate)
    previousBS = balanceSheet
   
economy = allEconomies[isim]
cashflows = total_cashflows[isim, :]

# Track portfolio composition
cash = initial_portfolio_value * cash_allocation
equities = initial_portfolio_value * equities_allocation
bonds = initial_portfolio_value * bonds_allocation

# Track rebalancing actions
cash_inflows = 0
cash_outflows = 0

for index in range(array_size):
    newBS = company.rollForward(previousBS, economy, cashflows, index)
    previousBS = newBS

    # Update portfolio composition
    cash = newBS.cash
    equities = newBS.equities
    bonds = newBS.bonds

    # Check if rebalancing is required
    if mainBasis.calcDate + index / mainBasis.pthly in rebalance_dates:
        # Calculate the new portfolio values after rebalancing
        total_value = cash + equities + bonds
        cash = cash_allocation * total_value
        equities = equities_allocation * total_value
        bonds = bonds_allocation * total_value

        # Calculate cash inflows or outflows due to rebalancing
        cash_inflows += cash - newBS.cash
        cash_outflows += newBS.cash - cash

# Calculate solvency after all transactions
solvency = cash + equities + bonds

# Print or store solvency and cash flows for this simulation
print(f"Simulation {isim + 1} - Solvency: {solvency:.2f}, Cash Inflows: {cash_inflows:.2f}, Cash Outflows: {cash_outflows:.2f}")   
   
